<?php
class Zend_Mime_Message { protected $_parts = array(); protected $_mime = null; public function getParts() { return $this->_parts; } public function setParts($parts) { $this->_parts = $parts; } public function addPart(Zend_Mime_Part $part) { $this->_parts[] = $part; } public function isMultiPart() { return (count($this->_parts) > 1); } public function setMime(Zend_Mime $mime) { $this->_mime = $mime; } public function getMime() { if ($this->_mime === null) { $this->_mime = new Zend_Mime(); } return $this->_mime; } public function generateMessage($EOL = Zend_Mime::LINEEND) { if (! $this->isMultiPart()) { $body = array_shift($this->_parts); $body = $body->getContent($EOL); } else { $mime = $this->getMime(); $boundaryLine = $mime->boundaryLine($EOL); $body = 'This is a message in Mime Format.  If you see this, ' . "your mail reader does not support this format." . $EOL; foreach (array_keys($this->_parts) as $p) { $body .= $boundaryLine . $this->getPartHeaders($p, $EOL) . $EOL . $this->getPartContent($p, $EOL); } $body .= $mime->mimeEnd($EOL); } return trim($body); } public function getPartHeadersArray($partnum) { return $this->_parts[$partnum]->getHeadersArray(); } public function getPartHeaders($partnum, $EOL = Zend_Mime::LINEEND) { return $this->_parts[$partnum]->getHeaders($EOL); } public function getPartContent($partnum, $EOL = Zend_Mime::LINEEND) { return $this->_parts[$partnum]->getContent($EOL); } protected static function _disassembleMime($body, $boundary) { $start = 0; $res = array(); $p = strpos($body, '--'.$boundary."\n", $start); if ($p === false) { return array(); } $start = $p + 3 + strlen($boundary); while (($p = strpos($body, '--' . $boundary . "\n", $start)) !== false) { $res[] = substr($body, $start, $p-$start); $start = $p + 3 + strlen($boundary); } $p = strpos($body, '--' . $boundary . '--', $start); if ($p===false) { throw new Zend_Exception('Not a valid Mime Message: End Missing'); } $res[] = substr($body, $start, $p-$start); return $res; } public static function createFromMessage($message, $boundary, $EOL = Zend_Mime::LINEEND) { $parts = Zend_Mime_Decode::splitMessageStruct($message, $boundary, $EOL); $res = new self(); foreach ($parts as $part) { $newPart = new Zend_Mime_Part($part['body']); foreach ($part['header'] as $key => $value) { switch(strtolower($key)) { case 'content-type': $newPart->type = $value; break; case 'content-transfer-encoding': $newPart->encoding = $value; break; case 'content-id': $newPart->id = trim($value,'<>'); break; case 'content-disposition': $newPart->disposition = $value; break; case 'content-description': $newPart->description = $value; break; case 'content-location': $newPart->location = $value; break; case 'content-language': $newPart->language = $value; break; default: throw new Zend_Exception('Unknown header ignored for MimePart:' . $key); } } $res->addPart($newPart); } return $res; } } 
class Zend_Mail extends Zend_Mime_Message { protected static $_defaultTransport = null; protected static $_defaultFrom; protected static $_defaultReplyTo; protected $_charset = null; protected $_headers = array(); protected $_headerEncoding = Zend_Mime::ENCODING_QUOTEDPRINTABLE; protected $_from = null; protected $_to = array(); protected $_recipients = array(); protected $_replyTo = null; protected $_returnPath = null; protected $_subject = null; protected $_date = null; protected $_messageId = null; protected $_bodyText = false; protected $_bodyHtml = false; protected $_mimeBoundary = null; protected $_type = null; public $hasAttachments = false; public static function setDefaultTransport(Zend_Mail_Transport_Abstract $transport) { self::$_defaultTransport = $transport; } public static function getDefaultTransport() { return self::$_defaultTransport; } public static function clearDefaultTransport() { self::$_defaultTransport = null; } public function __construct($charset = 'iso-8859-1') { $this->_charset = $charset; } public function getCharset() { return $this->_charset; } public function setType($type) { $allowed = array( Zend_Mime::MULTIPART_ALTERNATIVE, Zend_Mime::MULTIPART_MIXED, Zend_Mime::MULTIPART_RELATED, ); if (!in_array($type, $allowed)) { throw new Zend_Mail_Exception('Invalid content type "' . $type . '"'); } $this->_type = $type; return $this; } public function getType() { return $this->_type; } public function setMimeBoundary($boundary) { $this->_mimeBoundary = $boundary; return $this; } public function getMimeBoundary() { return $this->_mimeBoundary; } public function getEncodingOfHeaders() { return $this->getHeaderEncoding(); } public function getHeaderEncoding() { return $this->_headerEncoding; } public function setEncodingOfHeaders($encoding) { return $this->setHeaderEncoding($encoding); } public function setHeaderEncoding($encoding) { $allowed = array( Zend_Mime::ENCODING_BASE64, Zend_Mime::ENCODING_QUOTEDPRINTABLE ); if (!in_array($encoding, $allowed)) { throw new Zend_Mail_Exception('Invalid encoding "' . $encoding . '"'); } $this->_headerEncoding = $encoding; return $this; } public function setBodyText($txt, $charset = null, $encoding = Zend_Mime::ENCODING_QUOTEDPRINTABLE) { if ($charset === null) { $charset = $this->_charset; } $mp = new Zend_Mime_Part($txt); $mp->encoding = $encoding; $mp->type = Zend_Mime::TYPE_TEXT; $mp->disposition = Zend_Mime::DISPOSITION_INLINE; $mp->charset = $charset; $this->_bodyText = $mp; return $this; } public function getBodyText($textOnly = false) { if ($textOnly && $this->_bodyText) { $body = $this->_bodyText; return $body->getContent(); } return $this->_bodyText; } public function setBodyHtml($html, $charset = null, $encoding = Zend_Mime::ENCODING_QUOTEDPRINTABLE) { if ($charset === null) { $charset = $this->_charset; } $mp = new Zend_Mime_Part($html); $mp->encoding = $encoding; $mp->type = Zend_Mime::TYPE_HTML; $mp->disposition = Zend_Mime::DISPOSITION_INLINE; $mp->charset = $charset; $this->_bodyHtml = $mp; return $this; } public function getBodyHtml($htmlOnly = false) { if ($htmlOnly && $this->_bodyHtml) { $body = $this->_bodyHtml; return $body->getContent(); } return $this->_bodyHtml; } public function addAttachment(Zend_Mime_Part $attachment) { $this->addPart($attachment); $this->hasAttachments = true; return $this; } public function createAttachment($body, $mimeType = Zend_Mime::TYPE_OCTETSTREAM, $disposition = Zend_Mime::DISPOSITION_ATTACHMENT, $encoding = Zend_Mime::ENCODING_BASE64, $filename = null) { $mp = new Zend_Mime_Part($body); $mp->encoding = $encoding; $mp->type = $mimeType; $mp->disposition = $disposition; $mp->filename = $filename; $this->addAttachment($mp); return $mp; } public function getPartCount() { return count($this->_parts); } protected function _encodeHeader($value) { if (Zend_Mime::isPrintable($value) === false) { if ($this->getHeaderEncoding() === Zend_Mime::ENCODING_QUOTEDPRINTABLE) { $value = Zend_Mime::encodeQuotedPrintableHeader($value, $this->getCharset(), Zend_Mime::LINELENGTH, Zend_Mime::LINEEND); } else { $value = Zend_Mime::encodeBase64Header($value, $this->getCharset(), Zend_Mime::LINELENGTH, Zend_Mime::LINEEND); } } return $value; } protected function _storeHeader($headerName, $value, $append = false) { if (isset($this->_headers[$headerName])) { $this->_headers[$headerName][] = $value; } else { $this->_headers[$headerName] = array($value); } if ($append) { $this->_headers[$headerName]['append'] = true; } } protected function _clearHeader($headerName) { if (isset($this->_headers[$headerName])){ unset($this->_headers[$headerName]); } } protected function _addRecipientAndHeader($headerName, $email, $name) { $email = $this->_filterEmail($email); $name = $this->_filterName($name); $this->_recipients[$email] = 1; $this->_storeHeader($headerName, $this->_formatAddress($email, $name), true); } public function addTo($email, $name='') { if (!is_array($email)) { $email = array($name => $email); } foreach ($email as $n => $recipient) { $this->_addRecipientAndHeader('To', $recipient, is_int($n) ? '' : $n); $this->_to[] = $recipient; } return $this; } public function addCc($email, $name='') { if (!is_array($email)) { $email = array($name => $email); } foreach ($email as $n => $recipient) { $this->_addRecipientAndHeader('Cc', $recipient, is_int($n) ? '' : $n); } return $this; } public function addBcc($email) { if (!is_array($email)) { $email = array($email); } foreach ($email as $recipient) { $this->_addRecipientAndHeader('Bcc', $recipient, ''); } return $this; } public function getRecipients() { return array_keys($this->_recipients); } public function clearRecipients() { $this->_recipients = array(); $this->_to = array(); $this->_clearHeader('To'); $this->_clearHeader('Cc'); $this->_clearHeader('Bcc'); return $this; } public function setFrom($email, $name = null) { if (null !== $this->_from) { throw new Zend_Mail_Exception('From Header set twice'); } $email = $this->_filterEmail($email); $name = $this->_filterName($name); $this->_from = $email; $this->_storeHeader('From', $this->_formatAddress($email, $name), true); return $this; } public function setReplyTo($email, $name = null) { if (null !== $this->_replyTo) { throw new Zend_Mail_Exception('Reply-To Header set twice'); } $email = $this->_filterEmail($email); $name = $this->_filterName($name); $this->_replyTo = $email; $this->_storeHeader('Reply-To', $this->_formatAddress($email, $name), true); return $this; } public function getFrom() { return $this->_from; } public function getReplyTo() { return $this->_replyTo; } public function clearFrom() { $this->_from = null; $this->_clearHeader('From'); return $this; } public function clearReplyTo() { $this->_replyTo = null; $this->_clearHeader('Reply-To'); return $this; } public static function setDefaultFrom($email, $name = null) { self::$_defaultFrom = array('email' => $email, 'name' => $name); } public static function getDefaultFrom() { return self::$_defaultFrom; } public static function clearDefaultFrom() { self::$_defaultFrom = null; } public function setFromToDefaultFrom() { $from = self::getDefaultFrom(); if($from === null) { throw new Zend_Mail_Exception( 'No default From Address set to use'); } $this->setFrom($from['email'], $from['name']); return $this; } public static function setDefaultReplyTo($email, $name = null) { self::$_defaultReplyTo = array('email' => $email, 'name' => $name); } public static function getDefaultReplyTo() { return self::$_defaultReplyTo; } public static function clearDefaultReplyTo() { self::$_defaultReplyTo = null; } public function setReplyToFromDefault() { $replyTo = self::getDefaultReplyTo(); if($replyTo === null) { throw new Zend_Mail_Exception( 'No default Reply-To Address set to use'); } $this->setReplyTo($replyTo['email'], $replyTo['name']); return $this; } public function setReturnPath($email) { if ($this->_returnPath === null) { $email = $this->_filterEmail($email); $this->_returnPath = $email; $this->_storeHeader('Return-Path', $email, false); } else { throw new Zend_Mail_Exception('Return-Path Header set twice'); } return $this; } public function getReturnPath() { if (null !== $this->_returnPath) { return $this->_returnPath; } return $this->_from; } public function clearReturnPath() { $this->_returnPath = null; $this->_clearHeader('Return-Path'); return $this; } public function setSubject($subject) { if ($this->_subject === null) { $subject = $this->_filterOther($subject); $this->_subject = $this->_encodeHeader($subject); $this->_storeHeader('Subject', $this->_subject); } else { throw new Zend_Mail_Exception('Subject set twice'); } return $this; } public function getSubject() { return $this->_subject; } public function clearSubject() { $this->_subject = null; $this->_clearHeader('Subject'); return $this; } public function setDate($date = null) { if ($this->_date === null) { if ($date === null) { $date = date('r'); } else if (is_int($date)) { $date = date('r', $date); } else if (is_string($date)) { $date = strtotime($date); if ($date === false || $date < 0) { throw new Zend_Mail_Exception('String representations of Date Header must be ' . 'strtotime()-compatible'); } $date = date('r', $date); } else if ($date instanceof Zend_Date) { $date = $date->get(Zend_Date::RFC_2822); } else { throw new Zend_Mail_Exception(__METHOD__ . ' only accepts UNIX timestamps, Zend_Date objects, ' . ' and strtotime()-compatible strings'); } $this->_date = $date; $this->_storeHeader('Date', $date); } else { throw new Zend_Mail_Exception('Date Header set twice'); } return $this; } public function getDate() { return $this->_date; } public function clearDate() { $this->_date = null; $this->_clearHeader('Date'); return $this; } public function setMessageId($id = true) { if ($id === null || $id === false) { return $this; } elseif ($id === true) { $id = $this->createMessageId(); } if ($this->_messageId === null) { $id = $this->_filterOther($id); $this->_messageId = $id; $this->_storeHeader('Message-Id', '<' . $this->_messageId . '>'); } else { throw new Zend_Mail_Exception('Message-ID set twice'); } return $this; } public function getMessageId() { return $this->_messageId; } public function clearMessageId() { $this->_messageId = null; $this->_clearHeader('Message-Id'); return $this; } public function createMessageId() { $time = time(); if ($this->_from !== null) { $user = $this->_from; } elseif (isset($_SERVER['REMOTE_ADDR'])) { $user = $_SERVER['REMOTE_ADDR']; } else { $user = getmypid(); } $rand = mt_rand(); if ($this->_recipients !== array()) { $recipient = array_rand($this->_recipients); } else { $recipient = 'unknown'; } if (isset($_SERVER["SERVER_NAME"])) { $hostName = $_SERVER["SERVER_NAME"]; } else { $hostName = php_uname('n'); } return sha1($time . $user . $rand . $recipient) . '@' . $hostName; } public function addHeader($name, $value, $append = false) { $prohibit = array('to', 'cc', 'bcc', 'from', 'subject', 'reply-to', 'return-path', 'date', 'message-id', ); if (in_array(strtolower($name), $prohibit)) { throw new Zend_Mail_Exception('Cannot set standard header from addHeader()'); } $value = $this->_filterOther($value); $value = $this->_encodeHeader($value); $this->_storeHeader($name, $value, $append); return $this; } public function getHeaders() { return $this->_headers; } public function send($transport = null) { if ($transport === null) { if (! self::$_defaultTransport instanceof Zend_Mail_Transport_Abstract) { $transport = new Zend_Mail_Transport_Sendmail(); } else { $transport = self::$_defaultTransport; } } if ($this->_date === null) { $this->setDate(); } if(null === $this->_from && null !== self::getDefaultFrom()) { $this->setFromToDefaultFrom(); } if(null === $this->_replyTo && null !== self::getDefaultReplyTo()) { $this->setReplyToFromDefault(); } $transport->send($this); return $this; } protected function _filterEmail($email) { $rule = array("\r" => '', "\n" => '', "\t" => '', '"' => '', ',' => '', '<' => '', '>' => '', ); return strtr($email, $rule); } protected function _filterName($name) { $rule = array("\r" => '', "\n" => '', "\t" => '', '"' => "'", '<' => '[', '>' => ']', ); return trim(strtr($name, $rule)); } protected function _filterOther($data) { $rule = array("\r" => '', "\n" => '', "\t" => '', ); return strtr($data, $rule); } protected function _formatAddress($email, $name) { if ($name === '' || $name === null || $name === $email) { return $email; } else { $encodedName = $this->_encodeHeader($name); if ($encodedName === $name && ((strpos($name, '@') !== false) || (strpos($name, ',') !== false))) { $format = '"%s" <%s>'; } else { $format = '%s <%s>'; } return sprintf($format, $encodedName, $email); } } } 
abstract class Zend_Mail_Protocol_Abstract { const EOL = "\r\n"; const TIMEOUT_CONNECTION = 30; const MAXIMUM_LOG = 64; protected $_host; protected $_port; protected $_validHost; protected $_socket; protected $_request; protected $_response; protected $_template = '%d%s'; private $_log = array(); public function __construct($host = '127.0.0.1', $port = null) { $this->_validHost = new Zend_Validate(); $this->_validHost->addValidator(new Zend_Validate_Hostname(Zend_Validate_Hostname::ALLOW_ALL)); if (!$this->_validHost->isValid($host)) { throw new Zend_Mail_Protocol_Exception(join(', ', $this->_validHost->getMessages())); } $this->_host = $host; $this->_port = $port; } public function __destruct() { $this->_disconnect(); } abstract public function connect(); public function getRequest() { return $this->_request; } public function getResponse() { return $this->_response; } public function getLog() { return implode('', $this->_log); } public function resetLog() { $this->_log = array(); } protected function _addLog($value) { if (count($this->_log) >= self::MAXIMUM_LOG) { array_shift($this->_log); } $this->_log[] = $value; } protected function _connect($remote) { $errorNum = 0; $errorStr = ''; $this->_socket = @stream_socket_client($remote, $errorNum, $errorStr, self::TIMEOUT_CONNECTION); if ($this->_socket === false) { if ($errorNum == 0) { $errorStr = 'Could not open socket'; } throw new Zend_Mail_Protocol_Exception($errorStr); } if (($result = stream_set_timeout($this->_socket, self::TIMEOUT_CONNECTION)) === false) { throw new Zend_Mail_Protocol_Exception('Could not set stream timeout'); } return $result; } protected function _disconnect() { if (is_resource($this->_socket)) { fclose($this->_socket); } } protected function _send($request) { if (!is_resource($this->_socket)) { throw new Zend_Mail_Protocol_Exception('No connection has been established to ' . $this->_host); } $this->_request = $request; $result = fwrite($this->_socket, $request . self::EOL); $this->_addLog($request . self::EOL); if ($result === false) { throw new Zend_Mail_Protocol_Exception('Could not send request to ' . $this->_host); } return $result; } protected function _receive($timeout = null) { if (!is_resource($this->_socket)) { throw new Zend_Mail_Protocol_Exception('No connection has been established to ' . $this->_host); } if ($timeout !== null) { stream_set_timeout($this->_socket, $timeout); } $reponse = fgets($this->_socket, 1024); $this->_addLog($reponse); $info = stream_get_meta_data($this->_socket); if (!empty($info['timed_out'])) { throw new Zend_Mail_Protocol_Exception($this->_host . ' has timed out'); } if ($reponse === false) { throw new Zend_Mail_Protocol_Exception('Could not read from ' . $this->_host); } return $reponse; } protected function _expect($code, $timeout = null) { $this->_response = array(); $cmd = ''; $more = ''; $msg = ''; $errMsg = ''; if (!is_array($code)) { $code = array($code); } do { $this->_response[] = $result = $this->_receive($timeout); list($cmd, $more, $msg) = preg_split('/([\s-]+)/', $result, 2, PREG_SPLIT_DELIM_CAPTURE); if ($errMsg !== '') { $errMsg .= ' ' . $msg; } elseif ($cmd === null || !in_array($cmd, $code)) { $errMsg = $msg; } } while (strpos($more, '-') === 0); if ($errMsg !== '') { throw new Zend_Mail_Protocol_Exception($errMsg); } return $msg; } } 
class Zend_Mail_Protocol_Smtp extends Zend_Mail_Protocol_Abstract { protected $_transport = 'tcp'; protected $_secure; protected $_sess = false; protected $_helo = false; protected $_auth = false; protected $_mail = false; protected $_rcpt = false; protected $_data = null; public function __construct($host = '127.0.0.1', $port = null, array $config = array()) { if (isset($config['ssl'])) { switch (strtolower($config['ssl'])) { case 'tls': $this->_secure = 'tls'; break; case 'ssl': $this->_transport = 'ssl'; $this->_secure = 'ssl'; if ($port == null) { $port = 465; } break; default: throw new Zend_Mail_Protocol_Exception($config['ssl'] . ' is unsupported SSL type'); break; } } if ($port == null) { if (($port = ini_get('smtp_port')) == '') { $port = 25; } } parent::__construct($host, $port); } public function connect() { return $this->_connect($this->_transport . '://' . $this->_host . ':'. $this->_port); } public function helo($host = '127.0.0.1') { if ($this->_sess === true) { throw new Zend_Mail_Protocol_Exception('Cannot issue HELO to existing session'); } if (!$this->_validHost->isValid($host)) { throw new Zend_Mail_Protocol_Exception(join(', ', $this->_validHost->getMessages())); } $this->_expect(220, 300); $this->_ehlo($host); if ($this->_secure == 'tls') { $this->_send('STARTTLS'); $this->_expect(220, 180); if (!stream_socket_enable_crypto($this->_socket, true, STREAM_CRYPTO_METHOD_TLS_CLIENT)) { throw new Zend_Mail_Protocol_Exception('Unable to connect via TLS'); } $this->_ehlo($host); } $this->_startSession(); $this->auth(); } protected function _ehlo($host) { try { $this->_send('EHLO ' . $host); $this->_expect(250, 300); } catch (Zend_Mail_Protocol_Exception $e) { $this->_send('HELO ' . $host); $this->_expect(250, 300); } catch (Zend_Mail_Protocol_Exception $e) { throw $e; } } public function mail($from) { if ($this->_sess !== true) { throw new Zend_Mail_Protocol_Exception('A valid session has not been started'); } $this->_send('MAIL FROM:<' . $from . '>'); $this->_expect(250, 300); $this->_mail = true; $this->_rcpt = false; $this->_data = false; } public function rcpt($to) { if ($this->_mail !== true) { throw new Zend_Mail_Protocol_Exception('No sender reverse path has been supplied'); } $this->_send('RCPT TO:<' . $to . '>'); $this->_expect(array(250, 251), 300); $this->_rcpt = true; } public function data($data) { if ($this->_rcpt !== true) { throw new Zend_Mail_Protocol_Exception('No recipient forward path has been supplied'); } $this->_send('DATA'); $this->_expect(354, 120); foreach (explode(Zend_Mime::LINEEND, $data) as $line) { if (strpos($line, '.') === 0) { $line = '.' . $line; } $this->_send($line); } $this->_send('.'); $this->_expect(250, 600); $this->_data = true; } public function rset() { $this->_send('RSET'); $this->_expect(array(250, 220)); $this->_mail = false; $this->_rcpt = false; $this->_data = false; } public function noop() { $this->_send('NOOP'); $this->_expect(250, 300); } public function vrfy($user) { $this->_send('VRFY ' . $user); $this->_expect(array(250, 251, 252), 300); } public function quit() { if ($this->_sess) { $this->_send('QUIT'); $this->_expect(221, 300); $this->_stopSession(); } } public function auth() { if ($this->_auth === true) { throw new Zend_Mail_Protocol_Exception('Already authenticated for this session'); } } public function disconnect() { $this->_disconnect(); } protected function _startSession() { $this->_sess = true; } protected function _stopSession() { $this->_sess = false; } } 
class Zend_Mail_Protocol_Smtp_Auth_Crammd5 extends Zend_Mail_Protocol_Smtp { public function __construct($host = '127.0.0.1', $port = null, $config = null) { if (is_array($config)) { if (isset($config['username'])) { $this->_username = $config['username']; } if (isset($config['password'])) { $this->_password = $config['password']; } } parent::__construct($host, $port, $config); } public function auth() { parent::auth(); $this->_send('AUTH CRAM-MD5'); $challenge = $this->_expect(334); $challenge = base64_decode($challenge); $digest = $this->_hmacMd5($this->_password, $challenge); $this->_send(base64_encode($this->_username . ' ' . $digest)); $this->_expect(235); $this->_auth = true; } protected function _hmacMd5($key, $data, $block = 64) { if (strlen($key) > 64) { $key = pack('H32', md5($key)); } elseif (strlen($key) < 64) { $key = str_pad($key, $block, chr(0)); } $k_ipad = substr($key, 0, 64) ^ str_repeat(chr(0x36), 64); $k_opad = substr($key, 0, 64) ^ str_repeat(chr(0x5C), 64); $inner = pack('H32', md5($k_ipad . $data)); $digest = md5($k_opad . $inner); return $digest; } } 
class Zend_Mail_Protocol_Smtp_Auth_Login extends Zend_Mail_Protocol_Smtp { protected $_username; protected $_password; public function __construct($host = '127.0.0.1', $port = null, $config = null) { if (is_array($config)) { if (isset($config['username'])) { $this->_username = $config['username']; } if (isset($config['password'])) { $this->_password = $config['password']; } } parent::__construct($host, $port, $config); } public function auth() { parent::auth(); $this->_send('AUTH LOGIN'); $this->_expect(334); $this->_send(base64_encode($this->_username)); $this->_expect(334); $this->_send(base64_encode($this->_password)); $this->_expect(235); $this->_auth = true; } } 
class Zend_Mail_Protocol_Smtp_Auth_Plain extends Zend_Mail_Protocol_Smtp { protected $_username; protected $_password; public function __construct($host = '127.0.0.1', $port = null, $config = null) { if (is_array($config)) { if (isset($config['username'])) { $this->_username = $config['username']; } if (isset($config['password'])) { $this->_password = $config['password']; } } parent::__construct($host, $port, $config); } public function auth() { parent::auth(); $this->_send('AUTH PLAIN'); $this->_expect(334); $this->_send(base64_encode(chr(0) . $this->_username . chr(0) . $this->_password)); $this->_expect(235); $this->_auth = true; } } 
abstract class Zend_Mail_Transport_Abstract { public $body = ''; public $boundary = ''; public $header = ''; protected $_headers = array(); protected $_isMultipart = false; protected $_mail = false; protected $_parts = array(); public $recipients = ''; public $EOL = "\r\n"; abstract protected function _sendMail(); protected function _getHeaders($boundary) { if (null !== $boundary) { $type = $this->_mail->getType(); if (!$type) { if ($this->_mail->hasAttachments) { $type = Zend_Mime::MULTIPART_MIXED; } elseif ($this->_mail->getBodyText() && $this->_mail->getBodyHtml()) { $type = Zend_Mime::MULTIPART_ALTERNATIVE; } else { $type = Zend_Mime::MULTIPART_MIXED; } } $this->_headers['Content-Type'] = array( $type . ';' . $this->EOL . " " . 'boundary="' . $boundary . '"' ); $this->boundary = $boundary; } $this->_headers['MIME-Version'] = array('1.0'); return $this->_headers; } protected static function _formatHeader(&$item, $key, $prefix) { $item = $prefix . ': ' . $item; } protected function _prepareHeaders($headers) { if (!$this->_mail) { throw new Zend_Mail_Transport_Exception('Missing Zend_Mail object in _mail property'); } $this->header = ''; foreach ($headers as $header => $content) { if (isset($content['append'])) { unset($content['append']); $value = implode(',' . $this->EOL . ' ', $content); $this->header .= $header . ': ' . $value . $this->EOL; } else { array_walk($content, array(get_class($this), '_formatHeader'), $header); $this->header .= implode($this->EOL, $content) . $this->EOL; } } $sane = true; foreach (explode($this->EOL, $this->header) as $line) { if (strlen(trim($line)) > 998) { $sane = false; break; } } if (!$sane) { throw new Zend_Mail_Exception('At least one mail header line is too long'); } } protected function _buildBody() { if (($text = $this->_mail->getBodyText()) && ($html = $this->_mail->getBodyHtml())) { $mime = new Zend_Mime(null); $boundaryLine = $mime->boundaryLine($this->EOL); $boundaryEnd = $mime->mimeEnd($this->EOL); $text->disposition = false; $html->disposition = false; $body = $boundaryLine . $text->getHeaders($this->EOL) . $this->EOL . $text->getContent($this->EOL) . $this->EOL . $boundaryLine . $html->getHeaders($this->EOL) . $this->EOL . $html->getContent($this->EOL) . $this->EOL . $boundaryEnd; $mp = new Zend_Mime_Part($body); $mp->type = Zend_Mime::MULTIPART_ALTERNATIVE; $mp->boundary = $mime->boundary(); $this->_isMultipart = true; array_unshift($this->_parts, $mp); $this->_headers = $this->_mail->getHeaders(); return; } if (false !== ($body = $this->_mail->getBodyHtml())) { array_unshift($this->_parts, $body); } elseif (false !== ($body = $this->_mail->getBodyText())) { array_unshift($this->_parts, $body); } if (!$body) { throw new Zend_Mail_Transport_Exception('No body specified'); } $this->_headers = $this->_mail->getHeaders(); $headers = $body->getHeadersArray($this->EOL); foreach ($headers as $header) { $this->_headers[$header[0]] = array($header[1]); } } public function send(Zend_Mail $mail) { $this->_isMultipart = false; $this->_mail = $mail; $this->_parts = $mail->getParts(); $mime = $mail->getMime(); $this->_buildBody(); $count = count($this->_parts); $boundary = null; if ($count < 1) { throw new Zend_Mail_Transport_Exception('Empty mail cannot be sent'); } if ($count > 1) { $mime = new Zend_Mime($this->_mail->getMimeBoundary()); $boundary = $mime->boundary(); } elseif ($this->_isMultipart) { $boundary = $this->_parts[0]->boundary; } $this->recipients = implode(',', $mail->getRecipients()); $this->_prepareHeaders($this->_getHeaders($boundary)); $message = new Zend_Mime_Message(); $message->setParts($this->_parts); $message->setMime($mime); $this->body = $message->generateMessage($this->EOL); $this->_sendMail(); } } 
class Zend_Exception extends Exception { private $_previous = null; public function __construct($msg = '', $code = 0, Exception $previous = null) { if (version_compare(PHP_VERSION, '5.3.0', '<')) { parent::__construct($msg, (int) $code); $this->_previous = $previous; } else { parent::__construct($msg, (int) $code, $previous); } } public function __call($method, array $args) { if ('getprevious' == strtolower($method)) { return $this->_getPrevious(); } return null; } public function __toString() { if (version_compare(PHP_VERSION, '5.3.0', '<')) { if (null !== ($e = $this->getPrevious())) { return $e->__toString() . "\n\nNext " . parent::__toString(); } } return parent::__toString(); } protected function _getPrevious() { return $this->_previous; } } 
class Zend_Mail_Exception extends Zend_Exception {} 
class Zend_Mail_Transport_Exception extends Zend_Mail_Exception {} 
class Zend_Mail_Transport_Sendmail extends Zend_Mail_Transport_Abstract { public $subject = null; public $parameters; public $EOL = PHP_EOL; protected $_errstr; public function __construct($parameters = null) { if ($parameters instanceof Zend_Config) { $parameters = $parameters->toArray(); } if (is_array($parameters)) { $parameters = implode(' ', $parameters); } $this->parameters = $parameters; } public function _sendMail() { if ($this->parameters === null) { set_error_handler(array($this, '_handleMailErrors')); $result = mail( $this->recipients, $this->_mail->getSubject(), $this->body, $this->header); restore_error_handler(); } else { if(!is_string($this->parameters)) { throw new Zend_Mail_Transport_Exception( 'Parameters were set but are not a string' ); } set_error_handler(array($this, '_handleMailErrors')); $result = mail( $this->recipients, $this->_mail->getSubject(), $this->body, $this->header, $this->parameters); restore_error_handler(); } if ($this->_errstr !== null || !$result) { throw new Zend_Mail_Transport_Exception('Unable to send mail. ' . $this->_errstr); } } protected function _prepareHeaders($headers) { if (!$this->_mail) { throw new Zend_Mail_Transport_Exception('_prepareHeaders requires a registered Zend_Mail object'); } if (0 === strpos(PHP_OS, 'WIN')) { if (empty($this->recipients)) { throw new Zend_Mail_Transport_Exception('Missing To addresses'); } } else { if (!isset($headers['To'])) { throw new Zend_Mail_Transport_Exception('Missing To header'); } unset($headers['To']['append']); $this->recipients = implode(',', $headers['To']); } unset($headers['To']); if (isset($headers['Subject'])) { unset($headers['Subject']); } parent::_prepareHeaders($headers); $this->header = rtrim($this->header); } public function _handleMailErrors($errno, $errstr, $errfile = null, $errline = null, array $errcontext = null) { $this->_errstr = $errstr; return true; } } 
class Zend_Mail_Transport_Smtp extends Zend_Mail_Transport_Abstract { public $EOL = "\n"; protected $_host; protected $_port; protected $_name = 'localhost'; protected $_auth; protected $_config; protected $_connection; public function __construct($host = '127.0.0.1', Array $config = array()) { if (isset($config['name'])) { $this->_name = $config['name']; } if (isset($config['port'])) { $this->_port = $config['port']; } if (isset($config['auth'])) { $this->_auth = $config['auth']; } $this->_host = $host; $this->_config = $config; } public function __destruct() { if ($this->_connection instanceof Zend_Mail_Protocol_Smtp) { try { $this->_connection->quit(); } catch (Zend_Mail_Protocol_Exception $e) { } $this->_connection->disconnect(); } } public function setConnection(Zend_Mail_Protocol_Abstract $connection) { $this->_connection = $connection; } public function getConnection() { return $this->_connection; } public function _sendMail() { if (!($this->_connection instanceof Zend_Mail_Protocol_Smtp)) { $connectionClass = 'Zend_Mail_Protocol_Smtp'; if ($this->_auth) { $connectionClass .= '_Auth_' . ucwords($this->_auth); } if (!class_exists($connectionClass)) { Zend_Loader::loadClass($connectionClass); } $this->setConnection(new $connectionClass($this->_host, $this->_port, $this->_config)); $this->_connection->connect(); $this->_connection->helo($this->_name); } else { $this->_connection->rset(); } $this->_connection->mail($this->_mail->getFrom()); foreach ($this->_mail->getRecipients() as $recipient) { $this->_connection->rcpt($recipient); } $this->_connection->data($this->header . Zend_Mime::LINEEND . $this->body); } protected function _prepareHeaders($headers) { if (!$this->_mail) { throw new Zend_Mail_Transport_Exception('_prepareHeaders requires a registered Zend_Mail object'); } unset($headers['Bcc']); parent::_prepareHeaders($headers); } } 
interface Zend_Validate_Interface { public function isValid($value); public function getMessages(); } 
class Zend_Validate implements Zend_Validate_Interface { protected $_validators = array(); protected $_messages = array(); protected static $_defaultNamespaces = array(); protected $_errors = array(); public function addValidator(Zend_Validate_Interface $validator, $breakChainOnFailure = false) { $this->_validators[] = array( 'instance' => $validator, 'breakChainOnFailure' => (boolean) $breakChainOnFailure ); return $this; } public function isValid($value) { $this->_messages = array(); $this->_errors = array(); $result = true; foreach ($this->_validators as $element) { $validator = $element['instance']; if ($validator->isValid($value)) { continue; } $result = false; $messages = $validator->getMessages(); $this->_messages = array_merge($this->_messages, $messages); $this->_errors = array_merge($this->_errors, array_keys($messages)); if ($element['breakChainOnFailure']) { break; } } return $result; } public function getMessages() { return $this->_messages; } public function getErrors() { return $this->_errors; } public static function getDefaultNamespaces() { return self::$_defaultNamespaces; } public static function setDefaultNamespaces($namespace) { if (!is_array($namespace)) { $namespace = array((string) $namespace); } self::$_defaultNamespaces = $namespace; } public static function addDefaultNamespaces($namespace) { if (!is_array($namespace)) { $namespace = array((string) $namespace); } self::$_defaultNamespaces = array_unique(array_merge(self::$_defaultNamespaces, $namespace)); } public static function hasDefaultNamespaces() { return (!empty(self::$_defaultNamespaces)); } public static function is($value, $classBaseName, array $args = array(), $namespaces = array()) { $namespaces = array_merge((array) $namespaces, self::$_defaultNamespaces, array('Zend_Validate')); $className = ucfirst($classBaseName); try { if (!class_exists($className, false)) { foreach($namespaces as $namespace) { $class = $namespace . '_' . $className; $file = str_replace('_', DIRECTORY_SEPARATOR, $class) . '.php'; if (Zend_Loader::isReadable($file)) { Zend_Loader::loadClass($class); $className = $class; break; } } } $class = new ReflectionClass($className); if ($class->implementsInterface('Zend_Validate_Interface')) { if ($class->hasMethod('__construct')) { $keys = array_keys($args); $numeric = false; foreach($keys as $key) { if (is_numeric($key)) { $numeric = true; break; } } if ($numeric) { $object = $class->newInstanceArgs($args); } else { $object = $class->newInstance($args); } } else { $object = $class->newInstance(); } return $object->isValid($value); } } catch (Zend_Validate_Exception $ze) { throw $ze; } catch (Exception $e) { } throw new Zend_Validate_Exception("Validate class not found from basename '$classBaseName'"); } public static function getMessageLength() { return Zend_Validate_Abstract::getMessageLength(); } public static function setMessageLength($length = -1) { Zend_Validate_Abstract::setMessageLength($length); } public static function getDefaultTranslator($translator = null) { return Zend_Validate_Abstract::getDefaultTranslator(); } public static function setDefaultTranslator($translator = null) { Zend_Validate_Abstract::setDefaultTranslator($translator); } } 
abstract class Zend_Validate_Abstract implements Zend_Validate_Interface { protected $_value; protected $_messageVariables = array(); protected $_messageTemplates = array(); protected $_messages = array(); protected $_obscureValue = false; protected $_errors = array(); protected $_translator; protected static $_defaultTranslator; protected $_translatorDisabled = false; protected static $_messageLength = -1; public function getMessages() { return $this->_messages; } public function getMessageVariables() { return array_keys($this->_messageVariables); } public function getMessageTemplates() { return $this->_messageTemplates; } public function setMessage($messageString, $messageKey = null) { if ($messageKey === null) { $keys = array_keys($this->_messageTemplates); foreach($keys as $key) { $this->setMessage($messageString, $key); } return $this; } if (!isset($this->_messageTemplates[$messageKey])) { throw new Zend_Validate_Exception("No message template exists for key '$messageKey'"); } $this->_messageTemplates[$messageKey] = $messageString; return $this; } public function setMessages(array $messages) { foreach ($messages as $key => $message) { $this->setMessage($message, $key); } return $this; } public function __get($property) { if ($property == 'value') { return $this->_value; } if (array_key_exists($property, $this->_messageVariables)) { return $this->{$this->_messageVariables[$property]}; } throw new Zend_Validate_Exception("No property exists by the name '$property'"); } protected function _createMessage($messageKey, $value) { if (!isset($this->_messageTemplates[$messageKey])) { return null; } $message = $this->_messageTemplates[$messageKey]; if (null !== ($translator = $this->getTranslator())) { if ($translator->isTranslated($message)) { $message = $translator->translate($message); } elseif ($translator->isTranslated($messageKey)) { $message = $translator->translate($messageKey); } } if (is_object($value)) { if (!in_array('__toString', get_class_methods($value))) { $value = get_class($value) . ' object'; } else { $value = $value->__toString(); } } else { $value = (string)$value; } if ($this->getObscureValue()) { $value = str_repeat('*', strlen($value)); } $message = str_replace('%value%', (string) $value, $message); foreach ($this->_messageVariables as $ident => $property) { $message = str_replace("%$ident%", (string) $this->$property, $message); } $length = self::getMessageLength(); if (($length > -1) && (strlen($message) > $length)) { $message = substr($message, 0, (self::getMessageLength() - 3)) . '...'; } return $message; } protected function _error($messageKey, $value = null) { if ($messageKey === null) { $keys = array_keys($this->_messageTemplates); $messageKey = current($keys); } if ($value === null) { $value = $this->_value; } $this->_errors[] = $messageKey; $this->_messages[$messageKey] = $this->_createMessage($messageKey, $value); } protected function _setValue($value) { $this->_value = $value; $this->_messages = array(); $this->_errors = array(); } public function getErrors() { return $this->_errors; } public function setObscureValue($flag) { $this->_obscureValue = (bool) $flag; return $this; } public function getObscureValue() { return $this->_obscureValue; } public function setTranslator($translator = null) { if ((null === $translator) || ($translator instanceof Zend_Translate_Adapter)) { $this->_translator = $translator; } elseif ($translator instanceof Zend_Translate) { $this->_translator = $translator->getAdapter(); } else { throw new Zend_Validate_Exception('Invalid translator specified'); } return $this; } public function getTranslator() { if ($this->translatorIsDisabled()) { return null; } if (null === $this->_translator) { return self::getDefaultTranslator(); } return $this->_translator; } public function hasTranslator() { return (bool)$this->_translator; } public static function setDefaultTranslator($translator = null) { if ((null === $translator) || ($translator instanceof Zend_Translate_Adapter)) { self::$_defaultTranslator = $translator; } elseif ($translator instanceof Zend_Translate) { self::$_defaultTranslator = $translator->getAdapter(); } else { throw new Zend_Validate_Exception('Invalid translator specified'); } } public static function getDefaultTranslator() { if (null === self::$_defaultTranslator) { if (Zend_Registry::isRegistered('Zend_Translate')) { $translator = Zend_Registry::get('Zend_Translate'); if ($translator instanceof Zend_Translate_Adapter) { return $translator; } elseif ($translator instanceof Zend_Translate) { return $translator->getAdapter(); } } } return self::$_defaultTranslator; } public static function hasDefaultTranslator() { return (bool)self::$_defaultTranslator; } public function setDisableTranslator($flag) { $this->_translatorDisabled = (bool) $flag; return $this; } public function translatorIsDisabled() { return $this->_translatorDisabled; } public static function getMessageLength() { return self::$_messageLength; } public static function setMessageLength($length = -1) { self::$_messageLength = $length; } } 
class Zend_Validate_Hostname extends Zend_Validate_Abstract { const INVALID = 'hostnameInvalid'; const IP_ADDRESS_NOT_ALLOWED = 'hostnameIpAddressNotAllowed'; const UNKNOWN_TLD = 'hostnameUnknownTld'; const INVALID_DASH = 'hostnameDashCharacter'; const INVALID_HOSTNAME_SCHEMA = 'hostnameInvalidHostnameSchema'; const UNDECIPHERABLE_TLD = 'hostnameUndecipherableTld'; const INVALID_HOSTNAME = 'hostnameInvalidHostname'; const INVALID_LOCAL_NAME = 'hostnameInvalidLocalName'; const LOCAL_NAME_NOT_ALLOWED = 'hostnameLocalNameNotAllowed'; const CANNOT_DECODE_PUNYCODE = 'hostnameCannotDecodePunycode'; protected $_messageTemplates = array( self::INVALID => "Invalid type given, value should be a string", self::IP_ADDRESS_NOT_ALLOWED => "'%value%' appears to be an IP address, but IP addresses are not allowed", self::UNKNOWN_TLD => "'%value%' appears to be a DNS hostname but cannot match TLD against known list", self::INVALID_DASH => "'%value%' appears to be a DNS hostname but contains a dash in an invalid position", self::INVALID_HOSTNAME_SCHEMA => "'%value%' appears to be a DNS hostname but cannot match against hostname schema for TLD '%tld%'", self::UNDECIPHERABLE_TLD => "'%value%' appears to be a DNS hostname but cannot extract TLD part", self::INVALID_HOSTNAME => "'%value%' does not match the expected structure for a DNS hostname", self::INVALID_LOCAL_NAME => "'%value%' does not appear to be a valid local network name", self::LOCAL_NAME_NOT_ALLOWED => "'%value%' appears to be a local network name but local network names are not allowed", self::CANNOT_DECODE_PUNYCODE => "'%value%' appears to be a DNS hostname but the given punycode notation cannot be decoded", ); protected $_messageVariables = array( 'tld' => '_tld' ); const ALLOW_DNS = 1; const ALLOW_IP = 2; const ALLOW_LOCAL = 4; const ALLOW_ALL = 7; protected $_validTlds = array( 'ac', 'ad', 'ae', 'aero', 'af', 'ag', 'ai', 'al', 'am', 'an', 'ao', 'aq', 'ar', 'arpa', 'as', 'asia', 'at', 'au', 'aw', 'ax', 'az', 'ba', 'bb', 'bd', 'be', 'bf', 'bg', 'bh', 'bi', 'biz', 'bj', 'bm', 'bn', 'bo', 'br', 'bs', 'bt', 'bv', 'bw', 'by', 'bz', 'ca', 'cat', 'cc', 'cd', 'cf', 'cg', 'ch', 'ci', 'ck', 'cl', 'cm', 'cn', 'co', 'com', 'coop', 'cr', 'cu', 'cv', 'cx', 'cy', 'cz', 'de', 'dj', 'dk', 'dm', 'do', 'dz', 'ec', 'edu', 'ee', 'eg', 'er', 'es', 'et', 'eu', 'fi', 'fj', 'fk', 'fm', 'fo', 'fr', 'ga', 'gb', 'gd', 'ge', 'gf', 'gg', 'gh', 'gi', 'gl', 'gm', 'gn', 'gov', 'gp', 'gq', 'gr', 'gs', 'gt', 'gu', 'gw', 'gy', 'hk', 'hm', 'hn', 'hr', 'ht', 'hu', 'id', 'ie', 'il', 'im', 'in', 'info', 'int', 'io', 'iq', 'ir', 'is', 'it', 'je', 'jm', 'jo', 'jobs', 'jp', 'ke', 'kg', 'kh', 'ki', 'km', 'kn', 'kp', 'kr', 'kw', 'ky', 'kz', 'la', 'lb', 'lc', 'li', 'lk', 'lr', 'ls', 'lt', 'lu', 'lv', 'ly', 'ma', 'mc', 'md', 'me', 'mg', 'mh', 'mil', 'mk', 'ml', 'mm', 'mn', 'mo', 'mobi', 'mp', 'mq', 'mr', 'ms', 'mt', 'mu', 'museum', 'mv', 'mw', 'mx', 'my', 'mz', 'na', 'name', 'nc', 'ne', 'net', 'nf', 'ng', 'ni', 'nl', 'no', 'np', 'nr', 'nu', 'nz', 'om', 'org', 'pa', 'pe', 'pf', 'pg', 'ph', 'pk', 'pl', 'pm', 'pn', 'pr', 'pro', 'ps', 'pt', 'pw', 'py', 'qa', 're', 'ro', 'rs', 'ru', 'rw', 'sa', 'sb', 'sc', 'sd', 'se', 'sg', 'sh', 'si', 'sj', 'sk', 'sl', 'sm', 'sn', 'so', 'sr', 'st', 'su', 'sv', 'sy', 'sz', 'tc', 'td', 'tel', 'tf', 'tg', 'th', 'tj', 'tk', 'tl', 'tm', 'tn', 'to', 'tp', 'tr', 'travel', 'tt', 'tv', 'tw', 'tz', 'ua', 'ug', 'uk', 'um', 'us', 'uy', 'uz', 'va', 'vc', 've', 'vg', 'vi', 'vn', 'vu', 'wf', 'ws', 'ye', 'yt', 'yu', 'za', 'zm', 'zw' ); protected $_tld; protected $_validIdns = array( 'AC' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćĉċčďđēėęěĝġģĥħīįĵķĺļľŀłńņňŋőœŕŗřśŝşšţťŧūŭůűųŵŷźżž]{1,63}$/iu'), 'AR' => array(1 => '/^[\x{002d}0-9a-zà-ãç-êìíñ-õü]{1,63}$/iu'), 'AS' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĵķĸĺļľłńņňŋōŏőœŕŗřśŝşšţťŧũūŭůűųŵŷźż]{1,63}$/iu'), 'AT' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿœšž]{1,63}$/iu'), 'BIZ' => 'Hostname/Biz.php', 'BR' => array(1 => '/^[\x{002d}0-9a-zà-ãçéíó-õúü]{1,63}$/iu'), 'BV' => array(1 => '/^[\x{002d}0-9a-zàáä-éêñ-ôöøüčđńŋšŧž]{1,63}$/iu'), 'CAT' => array(1 => '/^[\x{002d}0-9a-z·àç-éíïòóúü]{1,63}$/iu'), 'CH' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿœ]{1,63}$/iu'), 'CL' => array(1 => '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu'), 'CN' => 'Hostname/Cn.php', 'COM' => 'Zend/Validate/Hostname/Com.php', 'DE' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿăąāćĉčċďđĕěėęēğĝġģĥħĭĩįīıĵķĺľļłńňņŋŏőōœĸŕřŗśŝšşťţŧŭůűũųūŵŷźžż]{1,63}$/iu'), 'DK' => array(1 => '/^[\x{002d}0-9a-zäéöü]{1,63}$/iu'), 'ES' => array(1 => '/^[\x{002d}0-9a-zàáçèéíïñòóúü·]{1,63}$/iu'), 'EU' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿ]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-zāăąćĉċčďđēĕėęěĝğġģĥħĩīĭįıĵķĺļľŀłńņňŉŋōŏőœŕŗřśŝšťŧũūŭůűųŵŷźżž]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-zșț]{1,63}$/iu', 4 => '/^[\x{002d}0-9a-zΐάέήίΰαβγδεζηθικλμνξοπρςστυφχψωϊϋόύώ]{1,63}$/iu', 5 => '/^[\x{002d}0-9a-zабвгдежзийклмнопрстуфхцчшщъыьэюя]{1,63}$/iu', 6 => '/^[\x{002d}0-9a-zἀ-ἇἐ-ἕἠ-ἧἰ-ἷὀ-ὅὐ-ὗὠ-ὧὰ-ώᾀ-ᾇᾐ-ᾗᾠ-ᾧᾰ-ᾴᾶᾷῂῃῄῆῇῐ-ΐῖῗῠ-ῧῲῳῴῶῷ]{1,63}$/iu'), 'FI' => array(1 => '/^[\x{002d}0-9a-zäåö]{1,63}$/iu'), 'GR' => array(1 => '/^[\x{002d}0-9a-zΆΈΉΊΌΎ-ΡΣ-ώἀ-ἕἘ-Ἕἠ-ὅὈ-Ὅὐ-ὗὙὛὝὟ-ώᾀ-ᾴᾶ-ᾼῂῃῄῆ-ῌῐ-ΐῖ-Ίῠ-Ῥῲῳῴῶ-ῼ]{1,63}$/iu'), 'HK' => 'Zend/Validate/Hostname/Cn.php', 'HU' => array(1 => '/^[\x{002d}0-9a-záéíóöúüőű]{1,63}$/iu'), 'INFO'=> array(1 => '/^[\x{002d}0-9a-zäåæéöøü]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-záéíóöúüőű]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-záæéíðóöúýþ]{1,63}$/iu', 4 => '/^[\x{AC00}-\x{D7A3}]{1,17}$/iu', 5 => '/^[\x{002d}0-9a-zāčēģīķļņōŗšūž]{1,63}$/iu', 6 => '/^[\x{002d}0-9a-ząčėęįšūųž]{1,63}$/iu', 7 => '/^[\x{002d}0-9a-zóąćęłńśźż]{1,63}$/iu', 8 => '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu'), 'IO' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿăąāćĉčċďđĕěėęēğĝġģĥħĭĩįīıĵķĺľļłńňņŋŏőōœĸŕřŗśŝšşťţŧŭůűũųūŵŷźžż]{1,63}$/iu'), 'IS' => array(1 => '/^[\x{002d}0-9a-záéýúíóþæöð]{1,63}$/iu'), 'JP' => 'Zend/Validate/Hostname/Jp.php', 'KR' => array(1 => '/^[\x{AC00}-\x{D7A3}]{1,17}$/iu'), 'LI' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿœ]{1,63}$/iu'), 'LT' => array(1 => '/^[\x{002d}0-9ąčęėįšųūž]{1,63}$/iu'), 'MD' => array(1 => '/^[\x{002d}0-9ăâîşţ]{1,63}$/iu'), 'MUSEUM' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćċčďđēėęěğġģħīįıķĺļľłńņňŋōőœŕŗřśşšţťŧūůűųŵŷźżžǎǐǒǔ\x{01E5}\x{01E7}\x{01E9}\x{01EF}ə\x{0292}ẁẃẅỳ]{1,63}$/iu'), 'NET' => 'Zend/Validate/Hostname/Com.php', 'NO' => array(1 => '/^[\x{002d}0-9a-zàáä-éêñ-ôöøüčđńŋšŧž]{1,63}$/iu'), 'NU' => 'Zend/Validate/Hostname/Com.php', 'ORG' => array(1 => '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu', 2 => '/^[\x{002d}0-9a-zóąćęłńśźż]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-záäåæéëíðóöøúüýþ]{1,63}$/iu', 4 => '/^[\x{002d}0-9a-záéíóöúüőű]{1,63}$/iu', 5 => '/^[\x{002d}0-9a-ząčėęįšūųž]{1,63}$/iu', 6 => '/^[\x{AC00}-\x{D7A3}]{1,17}$/iu', 7 => '/^[\x{002d}0-9a-zāčēģīķļņōŗšūž]{1,63}$/iu'), 'PE' => array(1 => '/^[\x{002d}0-9a-zñáéíóúü]{1,63}$/iu'), 'PL' => array(1 => '/^[\x{002d}0-9a-zāčēģīķļņōŗšūž]{1,63}$/iu', 2 => '/^[\x{002d}а-ик-ш\x{0450}ѓѕјљњќџ]{1,63}$/iu', 3 => '/^[\x{002d}0-9a-zâîăşţ]{1,63}$/iu', 4 => '/^[\x{002d}0-9а-яё\x{04C2}]{1,63}$/iu', 5 => '/^[\x{002d}0-9a-zàáâèéêìíîòóôùúûċġħż]{1,63}$/iu', 6 => '/^[\x{002d}0-9a-zàäåæéêòóôöøü]{1,63}$/iu', 7 => '/^[\x{002d}0-9a-zóąćęłńśźż]{1,63}$/iu', 8 => '/^[\x{002d}0-9a-zàáâãçéêíòóôõúü]{1,63}$/iu', 9 => '/^[\x{002d}0-9a-zâîăşţ]{1,63}$/iu', 10=> '/^[\x{002d}0-9a-záäéíóôúýčďĺľňŕšťž]{1,63}$/iu', 11=> '/^[\x{002d}0-9a-zçë]{1,63}$/iu', 12=> '/^[\x{002d}0-9а-ик-шђјљњћџ]{1,63}$/iu', 13=> '/^[\x{002d}0-9a-zćčđšž]{1,63}$/iu', 14=> '/^[\x{002d}0-9a-zâçöûüğış]{1,63}$/iu', 15=> '/^[\x{002d}0-9a-záéíñóúü]{1,63}$/iu', 16=> '/^[\x{002d}0-9a-zäõöüšž]{1,63}$/iu', 17=> '/^[\x{002d}0-9a-zĉĝĥĵŝŭ]{1,63}$/iu', 18=> '/^[\x{002d}0-9a-zâäéëîô]{1,63}$/iu', 19=> '/^[\x{002d}0-9a-zàáâäåæçèéêëìíîïðñòôöøùúûüýćčłńřśš]{1,63}$/iu', 20=> '/^[\x{002d}0-9a-zäåæõöøüšž]{1,63}$/iu', 21=> '/^[\x{002d}0-9a-zàáçèéìíòóùú]{1,63}$/iu', 22=> '/^[\x{002d}0-9a-zàáéíóöúüőű]{1,63}$/iu', 23=> '/^[\x{002d}0-9ΐά-ώ]{1,63}$/iu', 24=> '/^[\x{002d}0-9a-zàáâåæçèéêëðóôöøüþœ]{1,63}$/iu', 25=> '/^[\x{002d}0-9a-záäéíóöúüýčďěňřšťůž]{1,63}$/iu', 26=> '/^[\x{002d}0-9a-z·àçèéíïòóúü]{1,63}$/iu', 27=> '/^[\x{002d}0-9а-ъьюя\x{0450}\x{045D}]{1,63}$/iu', 28=> '/^[\x{002d}0-9а-яёіў]{1,63}$/iu', 29=> '/^[\x{002d}0-9a-ząčėęįšūųž]{1,63}$/iu', 30=> '/^[\x{002d}0-9a-záäåæéëíðóöøúüýþ]{1,63}$/iu', 31=> '/^[\x{002d}0-9a-zàâæçèéêëîïñôùûüÿœ]{1,63}$/iu', 32=> '/^[\x{002d}0-9а-щъыьэюяёєіїґ]{1,63}$/iu', 33=> '/^[\x{002d}0-9א-ת]{1,63}$/iu'), 'PR' => array(1 => '/^[\x{002d}0-9a-záéíóúñäëïüöâêîôûàèùæçœãõ]{1,63}$/iu'), 'PT' => array(1 => '/^[\x{002d}0-9a-záàâãçéêíóôõú]{1,63}$/iu'), 'RU' => array(1 => '/^[\x{002d}0-9а-яё]{1,63}$/iu'), 'SA' => array(1 => '/^[\x{002d}.0-9\x{0621}-\x{063A}\x{0641}-\x{064A}\x{0660}-\x{0669}]{1,63}$/iu'), 'SE' => array(1 => '/^[\x{002d}0-9a-zäåéöü]{1,63}$/iu'), 'SH' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿăąāćĉčċďđĕěėęēğĝġģĥħĭĩįīıĵķĺľļłńňņŋŏőōœĸŕřŗśŝšşťţŧŭůűũųūŵŷźžż]{1,63}$/iu'), 'SJ' => array(1 => '/^[\x{002d}0-9a-zàáä-éêñ-ôöøüčđńŋšŧž]{1,63}$/iu'), 'TH' => array(1 => '/^[\x{002d}0-9a-z\x{0E01}-\x{0E3A}\x{0E40}-\x{0E4D}\x{0E50}-\x{0E59}]{1,63}$/iu'), 'TM' => array(1 => '/^[\x{002d}0-9a-zà-öø-ÿāăąćĉċčďđēėęěĝġģĥħīįĵķĺļľŀłńņňŋőœŕŗřśŝşšţťŧūŭůűųŵŷźżž]{1,63}$/iu'), 'TW' => 'Zend/Validate/Hostname/Cn.php', 'TR' => array(1 => '/^[\x{002d}0-9a-zğıüşöç]{1,63}$/iu'), 'VE' => array(1 => '/^[\x{002d}0-9a-záéíóúüñ]{1,63}$/iu'), 'VN' => array(1 => '/^[ÀÁÂÃÈÉÊÌÍÒÓÔÕÙÚÝàáâãèéêìíòóôõùúýĂăĐđĨĩŨũƠơƯư\x{1EA0}-\x{1EF9}]{1,63}$/iu'), 'ایران' => array(1 => '/^[\x{0621}-\x{0624}\x{0626}-\x{063A}\x{0641}\x{0642}\x{0644}-\x{0648}\x{067E}\x{0686}\x{0698}\x{06A9}\x{06AF}\x{06CC}\x{06F0}-\x{06F9}]{1,30}$/iu'), '中国' => 'Zend/Validate/Hostname/Cn.php', '公司' => 'Zend/Validate/Hostname/Cn.php', '网络' => 'Zend/Validate/Hostname/Cn.php' ); protected $_idnLength = array( 'BIZ' => array(5 => 17, 11 => 15, 12 => 20), 'CN' => array(1 => 20), 'COM' => array(3 => 17, 5 => 20), 'HK' => array(1 => 15), 'INFO'=> array(4 => 17), 'KR' => array(1 => 17), 'NET' => array(3 => 17, 5 => 20), 'ORG' => array(6 => 17), 'TW' => array(1 => 20), 'ایران' => array(1 => 30), '中国' => array(1 => 20), '公司' => array(1 => 20), '网络' => array(1 => 20), ); protected $_options = array( 'allow' => self::ALLOW_DNS, 'idn' => true, 'tld' => true, 'ip' => null ); public function __construct($options = array()) { if ($options instanceof Zend_Config) { $options = $options->toArray(); } else if (!is_array($options)) { $options = func_get_args(); $temp['allow'] = array_shift($options); if (!empty($options)) { $temp['idn'] = array_shift($options); } if (!empty($options)) { $temp['tld'] = array_shift($options); } if (!empty($options)) { $temp['ip'] = array_shift($options); } $options = $temp; } $options += $this->_options; $this->setOptions($options); } public function getOptions() { return $this->_options; } public function setOptions($options) { if (array_key_exists('allow', $options)) { $this->setAllow($options['allow']); } if (array_key_exists('idn', $options)) { $this->setValidateIdn($options['idn']); } if (array_key_exists('tld', $options)) { $this->setValidateTld($options['tld']); } if (array_key_exists('ip', $options)) { $this->setIpValidator($options['ip']); } return $this; } public function getIpValidator() { return $this->_options['ip']; } public function setIpValidator(Zend_Validate_Ip $ipValidator = null) { if ($ipValidator === null) { $ipValidator = new Zend_Validate_Ip(); } $this->_options['ip'] = $ipValidator; return $this; } public function getAllow() { return $this->_options['allow']; } public function setAllow($allow) { $this->_options['allow'] = $allow; return $this; } public function getValidateIdn() { return $this->_options['idn']; } public function setValidateIdn ($allowed) { $this->_options['idn'] = (bool) $allowed; return $this; } public function getValidateTld() { return $this->_options['tld']; } public function setValidateTld ($allowed) { $this->_options['tld'] = (bool) $allowed; return $this; } public function isValid($value) { if (!is_string($value)) { $this->_error(self::INVALID); return false; } $this->_setValue($value); if (preg_match('/^[0-9.a-e:.]*$/i', $value) && $this->_options['ip']->setTranslator($this->getTranslator())->isValid($value)) { if (!($this->_options['allow'] & self::ALLOW_IP)) { $this->_error(self::IP_ADDRESS_NOT_ALLOWED); return false; } else { return true; } } $domainParts = explode('.', $value); if ((count($domainParts) > 1) && (strlen($value) >= 4) && (strlen($value) <= 254)) { $status = false; $origenc = iconv_get_encoding('internal_encoding'); iconv_set_encoding('internal_encoding', 'UTF-8'); do { $matches = array(); if (preg_match('/([^.]{2,10})$/i', end($domainParts), $matches) || (end($domainParts) == 'ایران') || (end($domainParts) == '中国') || (end($domainParts) == '公司') || (end($domainParts) == '网络')) { reset($domainParts); $this->_tld = strtolower($matches[1]); if ($this->_options['tld']) { if (!in_array($this->_tld, $this->_validTlds)) { $this->_error(self::UNKNOWN_TLD); $status = false; break; } } $regexChars = array(0 => '/^[a-z0-9\x2d]{1,63}$/i'); if ($this->_options['idn'] && isset($this->_validIdns[strtoupper($this->_tld)])) { if (is_string($this->_validIdns[strtoupper($this->_tld)])) { $regexChars += include($this->_validIdns[strtoupper($this->_tld)]); } else { $regexChars += $this->_validIdns[strtoupper($this->_tld)]; } } $check = 0; foreach ($domainParts as $domainPart) { if (strpos($domainPart, 'xn--') === 0) { $domainPart = $this->decodePunycode(substr($domainPart, 4)); if ($domainPart === false) { return false; } } if ((strpos($domainPart, '-') === 0) || ((strlen($domainPart) > 2) && (strpos($domainPart, '-', 2) == 2) && (strpos($domainPart, '-', 3) == 3)) || (strpos($domainPart, '-') === (strlen($domainPart) - 1))) { $this->_error(self::INVALID_DASH); $status = false; break 2; } $checked = false; foreach($regexChars as $regexKey => $regexChar) { $status = @preg_match($regexChar, $domainPart); if ($status > 0) { $length = 63; if (array_key_exists(strtoupper($this->_tld), $this->_idnLength) && (array_key_exists($regexKey, $this->_idnLength[strtoupper($this->_tld)]))) { $length = $this->_idnLength[strtoupper($this->_tld)]; } if (iconv_strlen($domainPart, 'UTF-8') > $length) { $this->_error(self::INVALID_HOSTNAME); } else { $checked = true; break; } } } if ($checked) { ++$check; } } if ($check !== count($domainParts)) { $this->_error(self::INVALID_HOSTNAME_SCHEMA); $status = false; } } else { $this->_error(self::UNDECIPHERABLE_TLD); $status = false; } } while (false); iconv_set_encoding('internal_encoding', $origenc); if ($status && ($this->_options['allow'] & self::ALLOW_DNS)) { return true; } } else if ($this->_options['allow'] & self::ALLOW_DNS) { $this->_error(self::INVALID_HOSTNAME); } $regexLocal = '/^(([a-zA-Z0-9\x2d]{1,63}\x2e)*[a-zA-Z0-9\x2d]{1,63}){1,254}$/'; $status = @preg_match($regexLocal, $value); $allowLocal = $this->_options['allow'] & self::ALLOW_LOCAL; if ($status && $allowLocal) { return true; } if (!$status) { $this->_error(self::INVALID_LOCAL_NAME); } if ($status && !$allowLocal) { $this->_error(self::LOCAL_NAME_NOT_ALLOWED); } return false; } protected function decodePunycode($encoded) { $found = preg_match('/([^a-z0-9\x2d]{1,10})$/i', $encoded); if (empty($encoded) || ($found > 0)) { $this->_error(self::CANNOT_DECODE_PUNYCODE); return false; } $separator = strrpos($encoded, '-'); if ($separator > 0) { for ($x = 0; $x < $separator; ++$x) { $decoded[] = ord($encoded[$x]); } } else { $this->_error(self::CANNOT_DECODE_PUNYCODE); return false; } $lengthd = count($decoded); $lengthe = strlen($encoded); $init = true; $base = 72; $index = 0; $char = 0x80; for ($indexe = ($separator) ? ($separator + 1) : 0; $indexe < $lengthe; ++$lengthd) { for ($old_index = $index, $pos = 1, $key = 36; 1 ; $key += 36) { $hex = ord($encoded[$indexe++]); $digit = ($hex - 48 < 10) ? $hex - 22 : (($hex - 65 < 26) ? $hex - 65 : (($hex - 97 < 26) ? $hex - 97 : 36)); $index += $digit * $pos; $tag = ($key <= $base) ? 1 : (($key >= $base + 26) ? 26 : ($key - $base)); if ($digit < $tag) { break; } $pos = (int) ($pos * (36 - $tag)); } $delta = intval($init ? (($index - $old_index) / 700) : (($index - $old_index) / 2)); $delta += intval($delta / ($lengthd + 1)); for ($key = 0; $delta > 910 / 2; $key += 36) { $delta = intval($delta / 35); } $base = intval($key + 36 * $delta / ($delta + 38)); $init = false; $char += (int) ($index / ($lengthd + 1)); $index %= ($lengthd + 1); if ($lengthd > 0) { for ($i = $lengthd; $i > $index; $i--) { $decoded[$i] = $decoded[($i - 1)]; } } $decoded[$index++] = $char; } foreach ($decoded as $key => $value) { if ($value < 128) { $decoded[$key] = chr($value); } elseif ($value < (1 << 11)) { $decoded[$key] = chr(192 + ($value >> 6)); $decoded[$key] .= chr(128 + ($value & 63)); } elseif ($value < (1 << 16)) { $decoded[$key] = chr(224 + ($value >> 12)); $decoded[$key] .= chr(128 + (($value >> 6) & 63)); $decoded[$key] .= chr(128 + ($value & 63)); } elseif ($value < (1 << 21)) { $decoded[$key] = chr(240 + ($value >> 18)); $decoded[$key] .= chr(128 + (($value >> 12) & 63)); $decoded[$key] .= chr(128 + (($value >> 6) & 63)); $decoded[$key] .= chr(128 + ($value & 63)); } else { $this->_error(self::CANNOT_DECODE_PUNYCODE); return false; } } return implode($decoded); } } 
class Zend_Mime { const TYPE_OCTETSTREAM = 'application/octet-stream'; const TYPE_TEXT = 'text/plain'; const TYPE_HTML = 'text/html'; const ENCODING_7BIT = '7bit'; const ENCODING_8BIT = '8bit'; const ENCODING_QUOTEDPRINTABLE = 'quoted-printable'; const ENCODING_BASE64 = 'base64'; const DISPOSITION_ATTACHMENT = 'attachment'; const DISPOSITION_INLINE = 'inline'; const LINELENGTH = 72; const LINEEND = "\n"; const MULTIPART_ALTERNATIVE = 'multipart/alternative'; const MULTIPART_MIXED = 'multipart/mixed'; const MULTIPART_RELATED = 'multipart/related'; protected $_boundary; protected static $makeUnique = 0; public static $qpKeys = array( "\x00","\x01","\x02","\x03","\x04","\x05","\x06","\x07", "\x08","\x09","\x0A","\x0B","\x0C","\x0D","\x0E","\x0F", "\x10","\x11","\x12","\x13","\x14","\x15","\x16","\x17", "\x18","\x19","\x1A","\x1B","\x1C","\x1D","\x1E","\x1F", "\x7F","\x80","\x81","\x82","\x83","\x84","\x85","\x86", "\x87","\x88","\x89","\x8A","\x8B","\x8C","\x8D","\x8E", "\x8F","\x90","\x91","\x92","\x93","\x94","\x95","\x96", "\x97","\x98","\x99","\x9A","\x9B","\x9C","\x9D","\x9E", "\x9F","\xA0","\xA1","\xA2","\xA3","\xA4","\xA5","\xA6", "\xA7","\xA8","\xA9","\xAA","\xAB","\xAC","\xAD","\xAE", "\xAF","\xB0","\xB1","\xB2","\xB3","\xB4","\xB5","\xB6", "\xB7","\xB8","\xB9","\xBA","\xBB","\xBC","\xBD","\xBE", "\xBF","\xC0","\xC1","\xC2","\xC3","\xC4","\xC5","\xC6", "\xC7","\xC8","\xC9","\xCA","\xCB","\xCC","\xCD","\xCE", "\xCF","\xD0","\xD1","\xD2","\xD3","\xD4","\xD5","\xD6", "\xD7","\xD8","\xD9","\xDA","\xDB","\xDC","\xDD","\xDE", "\xDF","\xE0","\xE1","\xE2","\xE3","\xE4","\xE5","\xE6", "\xE7","\xE8","\xE9","\xEA","\xEB","\xEC","\xED","\xEE", "\xEF","\xF0","\xF1","\xF2","\xF3","\xF4","\xF5","\xF6", "\xF7","\xF8","\xF9","\xFA","\xFB","\xFC","\xFD","\xFE", "\xFF" ); public static $qpReplaceValues = array( "=00","=01","=02","=03","=04","=05","=06","=07", "=08","=09","=0A","=0B","=0C","=0D","=0E","=0F", "=10","=11","=12","=13","=14","=15","=16","=17", "=18","=19","=1A","=1B","=1C","=1D","=1E","=1F", "=7F","=80","=81","=82","=83","=84","=85","=86", "=87","=88","=89","=8A","=8B","=8C","=8D","=8E", "=8F","=90","=91","=92","=93","=94","=95","=96", "=97","=98","=99","=9A","=9B","=9C","=9D","=9E", "=9F","=A0","=A1","=A2","=A3","=A4","=A5","=A6", "=A7","=A8","=A9","=AA","=AB","=AC","=AD","=AE", "=AF","=B0","=B1","=B2","=B3","=B4","=B5","=B6", "=B7","=B8","=B9","=BA","=BB","=BC","=BD","=BE", "=BF","=C0","=C1","=C2","=C3","=C4","=C5","=C6", "=C7","=C8","=C9","=CA","=CB","=CC","=CD","=CE", "=CF","=D0","=D1","=D2","=D3","=D4","=D5","=D6", "=D7","=D8","=D9","=DA","=DB","=DC","=DD","=DE", "=DF","=E0","=E1","=E2","=E3","=E4","=E5","=E6", "=E7","=E8","=E9","=EA","=EB","=EC","=ED","=EE", "=EF","=F0","=F1","=F2","=F3","=F4","=F5","=F6", "=F7","=F8","=F9","=FA","=FB","=FC","=FD","=FE", "=FF" ); public static $qpKeysString = "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F\x7F\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF"; public static function isPrintable($str) { return (strcspn($str, self::$qpKeysString) == strlen($str)); } public static function encodeQuotedPrintable($str, $lineLength = self::LINELENGTH, $lineEnd = self::LINEEND) { $out = ''; $str = self::_encodeQuotedPrintable($str); while ($str) { $ptr = strlen($str); if ($ptr > $lineLength) { $ptr = $lineLength; } $pos = strrpos(substr($str, 0, $ptr), '='); if ($pos !== false && $pos >= $ptr - 2) { $ptr = $pos; } if ($ptr > 0 && $str[$ptr - 1] == ' ') { --$ptr; } $out .= substr($str, 0, $ptr) . '=' . $lineEnd; $str = substr($str, $ptr); } $out = rtrim($out, $lineEnd); $out = rtrim($out, '='); return $out; } private static function _encodeQuotedPrintable($str) { $str = str_replace('=', '=3D', $str); $str = str_replace(self::$qpKeys, self::$qpReplaceValues, $str); $str = rtrim($str); return $str; } public static function encodeQuotedPrintableHeader($str, $charset, $lineLength = self::LINELENGTH, $lineEnd = self::LINEEND) { $prefix = sprintf('=?%s?Q?', $charset); $lineLength = $lineLength-strlen($prefix)-3; $str = self::_encodeQuotedPrintable($str); $str = str_replace(array('?', ' ', '_'), array('=3F', '=20', '=5F'), $str); $lines = array(0 => ""); $tmp = ""; while(strlen($str) > 0) { $currentLine = max(count($lines)-1, 0); $token = self::getNextQuotedPrintableToken($str); $str = substr($str, strlen($token)); $tmp .= $token; if($token == '=20') { if(strlen($lines[$currentLine].$tmp) > $lineLength) { $lines[$currentLine+1] = $tmp; } else { $lines[$currentLine] .= $tmp; } $tmp = ""; } if(strlen($str) == 0) { $lines[$currentLine] .= $tmp; } } for($i = 0; $i < count($lines); $i++) { $lines[$i] = " ".$prefix.$lines[$i]."?="; } $str = trim(implode($lineEnd, $lines)); return $str; } private static function getNextQuotedPrintableToken($str) { if(substr($str, 0, 1) == "=") { $token = substr($str, 0, 3); } else { $token = substr($str, 0, 1); } return $token; } public static function encodeBase64Header($str, $charset, $lineLength = self::LINELENGTH, $lineEnd = self::LINEEND) { $prefix = '=?' . $charset . '?B?'; $suffix = '?='; $remainingLength = $lineLength - strlen($prefix) - strlen($suffix); $encodedValue = self::encodeBase64($str, $remainingLength, $lineEnd); $encodedValue = str_replace($lineEnd, $suffix . $lineEnd . ' ' . $prefix, $encodedValue); $encodedValue = $prefix . $encodedValue . $suffix; return $encodedValue; } public static function encodeBase64($str, $lineLength = self::LINELENGTH, $lineEnd = self::LINEEND) { return rtrim(chunk_split(base64_encode($str), $lineLength, $lineEnd)); } public function __construct($boundary = null) { if ($boundary === null) { $this->_boundary = '=_' . md5(microtime(1) . self::$makeUnique++); } else { $this->_boundary = $boundary; } } public static function encode($str, $encoding, $EOL = self::LINEEND) { switch ($encoding) { case self::ENCODING_BASE64: return self::encodeBase64($str, self::LINELENGTH, $EOL); case self::ENCODING_QUOTEDPRINTABLE: return self::encodeQuotedPrintable($str, self::LINELENGTH, $EOL); default: return $str; } } public function boundary() { return $this->_boundary; } public function boundaryLine($EOL = self::LINEEND) { return $EOL . '--' . $this->_boundary . $EOL; } public function mimeEnd($EOL = self::LINEEND) { return $EOL . '--' . $this->_boundary . '--' . $EOL; } } 
class Zend_Mime_Exception extends Zend_Exception {} 
class Zend_Mime_Part { public $type = Zend_Mime::TYPE_OCTETSTREAM; public $encoding = Zend_Mime::ENCODING_8BIT; public $id; public $disposition; public $filename; public $description; public $charset; public $boundary; public $location; public $language; protected $_content; protected $_isStream = false; public function __construct($content) { $this->_content = $content; if (is_resource($content)) { $this->_isStream = true; } } public function isStream() { return $this->_isStream; } public function getEncodedStream() { if (!$this->_isStream) { throw new Zend_Mime_Exception('Attempt to get a stream from a string part'); } switch ($this->encoding) { case Zend_Mime::ENCODING_QUOTEDPRINTABLE: $filter = stream_filter_append( $this->_content, 'convert.quoted-printable-encode', STREAM_FILTER_READ, array( 'line-length' => 76, 'line-break-chars' => Zend_Mime::LINEEND ) ); if (!is_resource($filter)) { throw new Zend_Mime_Exception('Failed to append quoted-printable filter'); } break; case Zend_Mime::ENCODING_BASE64: $filter = stream_filter_append( $this->_content, 'convert.base64-encode', STREAM_FILTER_READ, array( 'line-length' => 76, 'line-break-chars' => Zend_Mime::LINEEND ) ); if (!is_resource($filter)) { throw new Zend_Mime_Exception('Failed to append base64 filter'); } break; default: } return $this->_content; } public function getContent($EOL = Zend_Mime::LINEEND) { if ($this->_isStream) { return stream_get_contents($this->getEncodedStream()); } else { return Zend_Mime::encode($this->_content, $this->encoding, $EOL); } } public function getHeadersArray($EOL = Zend_Mime::LINEEND) { $headers = array(); $contentType = $this->type; if ($this->charset) { $contentType .= '; charset=' . $this->charset; } if ($this->boundary) { $contentType .= ';' . $EOL . " boundary=\"" . $this->boundary . '"'; } $headers[] = array('Content-Type', $contentType); if ($this->encoding) { $headers[] = array('Content-Transfer-Encoding', $this->encoding); } if ($this->id) { $headers[] = array('Content-ID', '<' . $this->id . '>'); } if ($this->disposition) { $disposition = $this->disposition; if ($this->filename) { $disposition .= '; filename="' . $this->filename . '"'; } $headers[] = array('Content-Disposition', $disposition); } if ($this->description) { $headers[] = array('Content-Description', $this->description); } if ($this->location) { $headers[] = array('Content-Location', $this->location); } if ($this->language){ $headers[] = array('Content-Language', $this->language); } return $headers; } public function getHeaders($EOL = Zend_Mime::LINEEND) { $res = ''; foreach ($this->getHeadersArray($EOL) as $header) { $res .= $header[0] . ': ' . $header[1] . $EOL; } return $res; } } 
class Zend_Mime_Decode { public static function splitMime($body, $boundary) { $body = str_replace("\r", '', $body); $start = 0; $res = array(); $p = strpos($body, '--' . $boundary . "\n", $start); if ($p === false) { return array(); } $start = $p + 3 + strlen($boundary); while (($p = strpos($body, '--' . $boundary . "\n", $start)) !== false) { $res[] = substr($body, $start, $p-$start); $start = $p + 3 + strlen($boundary); } $p = strpos($body, '--' . $boundary . '--', $start); if ($p===false) { throw new Zend_Exception('Not a valid Mime Message: End Missing'); } $res[] = substr($body, $start, $p-$start); return $res; } public static function splitMessageStruct($message, $boundary, $EOL = Zend_Mime::LINEEND) { $parts = self::splitMime($message, $boundary); if (count($parts) <= 0) { return null; } $result = array(); foreach ($parts as $part) { self::splitMessage($part, $headers, $body, $EOL); $result[] = array('header' => $headers, 'body' => $body ); } return $result; } public static function splitMessage($message, &$headers, &$body, $EOL = Zend_Mime::LINEEND) { $firstline = strtok($message, "\n"); if (!preg_match('%^[^\s]+[^:]*:%', $firstline)) { $headers = array(); $body = str_replace(array("\r", "\n"), array('', $EOL), $message); return; } if (strpos($message, $EOL . $EOL)) { list($headers, $body) = explode($EOL . $EOL, $message, 2); } else if ($EOL != "\r\n" && strpos($message, "\r\n\r\n")) { list($headers, $body) = explode("\r\n\r\n", $message, 2); } else if ($EOL != "\n" && strpos($message, "\n\n")) { list($headers, $body) = explode("\n\n", $message, 2); } else { @list($headers, $body) = @preg_split("%([\r\n]+)\\1%U", $message, 2); } $headers = iconv_mime_decode_headers($headers, ICONV_MIME_DECODE_CONTINUE_ON_ERROR); if ($headers === false ) { return; } foreach ($headers as $name => $header) { $lower = strtolower($name); if ($lower == $name) { continue; } unset($headers[$name]); if (!isset($headers[$lower])) { $headers[$lower] = $header; continue; } if (is_array($headers[$lower])) { $headers[$lower][] = $header; continue; } $headers[$lower] = array($headers[$lower], $header); } } public static function splitContentType($type, $wantedPart = null) { return self::splitHeaderField($type, $wantedPart, 'type'); } public static function splitHeaderField($field, $wantedPart = null, $firstName = 0) { $wantedPart = strtolower($wantedPart); $firstName = strtolower($firstName); if ($firstName === $wantedPart) { $field = strtok($field, ';'); return $field[0] == '"' ? substr($field, 1, -1) : $field; } $field = $firstName . '=' . $field; if (!preg_match_all('%([^=\s]+)\s*=\s*("[^"]+"|[^;]+)(;\s*|$)%', $field, $matches)) { throw new Zend_Exception('not a valid header field'); } if ($wantedPart) { foreach ($matches[1] as $key => $name) { if (strcasecmp($name, $wantedPart)) { continue; } if ($matches[2][$key][0] != '"') { return $matches[2][$key]; } return substr($matches[2][$key], 1, -1); } return null; } $split = array(); foreach ($matches[1] as $key => $name) { $name = strtolower($name); if ($matches[2][$key][0] == '"') { $split[$name] = substr($matches[2][$key], 1, -1); } else { $split[$name] = $matches[2][$key]; } } return $split; } public static function decodeQuotedPrintable($string) { return iconv_mime_decode($string, ICONV_MIME_DECODE_CONTINUE_ON_ERROR); } } 
class Zend_Loader { public static function loadClass($class, $dirs = null) { if (class_exists($class, false) || interface_exists($class, false)) { return; } if ((null !== $dirs) && !is_string($dirs) && !is_array($dirs)) { throw new Zend_Exception('Directory argument must be a string or an array'); } $className = ltrim($class, '\\'); $file = ''; $namespace = ''; if ($lastNsPos = strripos($className, '\\')) { $namespace = substr($className, 0, $lastNsPos); $className = substr($className, $lastNsPos + 1); $file = str_replace('\\', DIRECTORY_SEPARATOR, $namespace) . DIRECTORY_SEPARATOR; } $file .= str_replace('_', DIRECTORY_SEPARATOR, $className) . '.php'; if (!empty($dirs)) { $dirPath = dirname($file); if (is_string($dirs)) { $dirs = explode(PATH_SEPARATOR, $dirs); } foreach ($dirs as $key => $dir) { if ($dir == '.') { $dirs[$key] = $dirPath; } else { $dir = rtrim($dir, '\\/'); $dirs[$key] = $dir . DIRECTORY_SEPARATOR . $dirPath; } } $file = basename($file); self::loadFile($file, $dirs, true); } else { self::loadFile($file, null, true); } if (!class_exists($class, false) && !interface_exists($class, false)) { throw new Zend_Exception("File \"$file\" does not exist or class \"$class\" was not found in the file"); } } public static function loadFile($filename, $dirs = null, $once = false) { self::_securityCheck($filename); $incPath = false; if (!empty($dirs) && (is_array($dirs) || is_string($dirs))) { if (is_array($dirs)) { $dirs = implode(PATH_SEPARATOR, $dirs); } $incPath = get_include_path(); set_include_path($dirs . PATH_SEPARATOR . $incPath); } if ($once) { include_once $filename; } else { include $filename; } if ($incPath) { set_include_path($incPath); } return true; } public static function isReadable($filename) { if (is_readable($filename)) { return true; } if (strtoupper(substr(PHP_OS, 0, 3)) == 'WIN' && preg_match('/^[a-z]:/i', $filename) ) { return false; } foreach (self::explodeIncludePath() as $path) { if ($path == '.') { if (is_readable($filename)) { return true; } continue; } $file = $path . '/' . $filename; if (is_readable($file)) { return true; } } return false; } public static function explodeIncludePath($path = null) { if (null === $path) { $path = get_include_path(); } if (PATH_SEPARATOR == ':') { $paths = preg_split('#:(?!//)#', $path); } else { $paths = explode(PATH_SEPARATOR, $path); } return $paths; } public static function autoload($class) { trigger_error(__CLASS__ . '::' . __METHOD__ . ' is deprecated as of 1.8.0 and will be removed with 2.0.0; use Zend_Loader_Autoloader instead', E_USER_NOTICE); try { @self::loadClass($class); return $class; } catch (Exception $e) { return false; } } public static function registerAutoload($class = 'Zend_Loader', $enabled = true) { trigger_error(__CLASS__ . '::' . __METHOD__ . ' is deprecated as of 1.8.0 and will be removed with 2.0.0; use Zend_Loader_Autoloader instead', E_USER_NOTICE); $autoloader = Zend_Loader_Autoloader::getInstance(); $autoloader->setFallbackAutoloader(true); if ('Zend_Loader' != $class) { self::loadClass($class); $methods = get_class_methods($class); if (!in_array('autoload', (array) $methods)) { throw new Zend_Exception("The class \"$class\" does not have an autoload() method"); } $callback = array($class, 'autoload'); if ($enabled) { $autoloader->pushAutoloader($callback); } else { $autoloader->removeAutoloader($callback); } } } protected static function _securityCheck($filename) { if (preg_match('/[^a-z0-9\\/\\\\_.:-]/i', $filename)) { throw new Zend_Exception('Security check: Illegal character in filename'); } } protected static function _includeFile($filespec, $once = false) { if ($once) { return include_once $filespec; } else { return include $filespec ; } } } 
class Zend_Loader_Autoloader { protected static $_instance; protected $_autoloaders = array(); protected $_defaultAutoloader = array('Zend_Loader', 'loadClass'); protected $_fallbackAutoloader = false; protected $_internalAutoloader; protected $_namespaces = array( 'Zend_' => true, 'ZendX_' => true, ); protected $_namespaceAutoloaders = array(); protected $_suppressNotFoundWarnings = false; protected $_zfPath; public static function getInstance() { if (null === self::$_instance) { self::$_instance = new self(); } return self::$_instance; } public static function resetInstance() { self::$_instance = null; } public static function autoload($class) { $self = self::getInstance(); foreach ($self->getClassAutoloaders($class) as $autoloader) { if ($autoloader instanceof Zend_Loader_Autoloader_Interface) { if ($autoloader->autoload($class)) { return true; } } elseif (is_string($autoloader)) { if ($autoloader($class)) { return true; } } elseif (is_array($autoloader)) { $object = array_shift($autoloader); $method = array_shift($autoloader); if (call_user_func(array($object, $method), $class)) { return true; } } } return false; } public function setDefaultAutoloader($callback) { if (!is_callable($callback)) { throw new Zend_Loader_Exception('Invalid callback specified for default autoloader'); } $this->_defaultAutoloader = $callback; return $this; } public function getDefaultAutoloader() { return $this->_defaultAutoloader; } public function setAutoloaders(array $autoloaders) { $this->_autoloaders = $autoloaders; return $this; } public function getAutoloaders() { return $this->_autoloaders; } public function getNamespaceAutoloaders($namespace) { $namespace = (string) $namespace; if (!array_key_exists($namespace, $this->_namespaceAutoloaders)) { return array(); } return $this->_namespaceAutoloaders[$namespace]; } public function registerNamespace($namespace) { if (is_string($namespace)) { $namespace = (array) $namespace; } elseif (!is_array($namespace)) { throw new Zend_Loader_Exception('Invalid namespace provided'); } foreach ($namespace as $ns) { if (!isset($this->_namespaces[$ns])) { $this->_namespaces[$ns] = true; } } return $this; } public function unregisterNamespace($namespace) { if (is_string($namespace)) { $namespace = (array) $namespace; } elseif (!is_array($namespace)) { throw new Zend_Loader_Exception('Invalid namespace provided'); } foreach ($namespace as $ns) { if (isset($this->_namespaces[$ns])) { unset($this->_namespaces[$ns]); } } return $this; } public function getRegisteredNamespaces() { return array_keys($this->_namespaces); } public function setZfPath($spec, $version = 'latest') { $path = $spec; if (is_array($spec)) { if (!isset($spec['path'])) { throw new Zend_Loader_Exception('No path specified for ZF'); } $path = $spec['path']; if (isset($spec['version'])) { $version = $spec['version']; } } $this->_zfPath = $this->_getVersionPath($path, $version); set_include_path(implode(PATH_SEPARATOR, array( $this->_zfPath, get_include_path(), ))); return $this; } public function getZfPath() { return $this->_zfPath; } public function suppressNotFoundWarnings($flag = null) { if (null === $flag) { return $this->_suppressNotFoundWarnings; } $this->_suppressNotFoundWarnings = (bool) $flag; return $this; } public function setFallbackAutoloader($flag) { $this->_fallbackAutoloader = (bool) $flag; return $this; } public function isFallbackAutoloader() { return $this->_fallbackAutoloader; } public function getClassAutoloaders($class) { $namespace = false; $autoloaders = array(); foreach (array_keys($this->_namespaceAutoloaders) as $ns) { if ('' == $ns) { continue; } if (0 === strpos($class, $ns)) { $namespace = $ns; $autoloaders = $autoloaders + $this->getNamespaceAutoloaders($ns); break; } } foreach ($this->getRegisteredNamespaces() as $ns) { if (0 === strpos($class, $ns)) { $namespace = $ns; $autoloaders[] = $this->_internalAutoloader; break; } } $autoloaders = $autoloaders + $this->getNamespaceAutoloaders(''); if (!$namespace && $this->isFallbackAutoloader()) { $autoloaders[] = $this->_internalAutoloader; } return $autoloaders; } public function unshiftAutoloader($callback, $namespace = '') { $autoloaders = $this->getAutoloaders(); array_unshift($autoloaders, $callback); $this->setAutoloaders($autoloaders); $namespace = (array) $namespace; foreach ($namespace as $ns) { $autoloaders = $this->getNamespaceAutoloaders($ns); array_unshift($autoloaders, $callback); $this->_setNamespaceAutoloaders($autoloaders, $ns); } return $this; } public function pushAutoloader($callback, $namespace = '') { $autoloaders = $this->getAutoloaders(); array_push($autoloaders, $callback); $this->setAutoloaders($autoloaders); $namespace = (array) $namespace; foreach ($namespace as $ns) { $autoloaders = $this->getNamespaceAutoloaders($ns); array_push($autoloaders, $callback); $this->_setNamespaceAutoloaders($autoloaders, $ns); } return $this; } public function removeAutoloader($callback, $namespace = null) { if (null === $namespace) { $autoloaders = $this->getAutoloaders(); if (false !== ($index = array_search($callback, $autoloaders, true))) { unset($autoloaders[$index]); $this->setAutoloaders($autoloaders); } foreach ($this->_namespaceAutoloaders as $ns => $autoloaders) { if (false !== ($index = array_search($callback, $autoloaders, true))) { unset($autoloaders[$index]); $this->_setNamespaceAutoloaders($autoloaders, $ns); } } } else { $namespace = (array) $namespace; foreach ($namespace as $ns) { $autoloaders = $this->getNamespaceAutoloaders($ns); if (false !== ($index = array_search($callback, $autoloaders, true))) { unset($autoloaders[$index]); $this->_setNamespaceAutoloaders($autoloaders, $ns); } } } return $this; } protected function __construct() { spl_autoload_register(array(__CLASS__, 'autoload')); $this->_internalAutoloader = array($this, '_autoload'); } protected function _autoload($class) { $callback = $this->getDefaultAutoloader(); try { if ($this->suppressNotFoundWarnings()) { @call_user_func($callback, $class); } else { call_user_func($callback, $class); } return $class; } catch (Zend_Exception $e) { return false; } } protected function _setNamespaceAutoloaders(array $autoloaders, $namespace = '') { $namespace = (string) $namespace; $this->_namespaceAutoloaders[$namespace] = $autoloaders; return $this; } protected function _getVersionPath($path, $version) { $type = $this->_getVersionType($version); if ($type == 'latest') { $version = 'latest'; } $availableVersions = $this->_getAvailableVersions($path, $version); if (empty($availableVersions)) { throw new Zend_Loader_Exception('No valid ZF installations discovered'); } $matchedVersion = array_pop($availableVersions); return $matchedVersion; } protected function _getVersionType($version) { if (strtolower($version) == 'latest') { return 'latest'; } $parts = explode('.', $version); $count = count($parts); if (1 == $count) { return 'major'; } if (2 == $count) { return 'minor'; } if (3 < $count) { throw new Zend_Loader_Exception('Invalid version string provided'); } return 'specific'; } protected function _getAvailableVersions($path, $version) { if (!is_dir($path)) { throw new Zend_Loader_Exception('Invalid ZF path provided'); } $path = rtrim($path, '/'); $path = rtrim($path, '\\'); $versionLen = strlen($version); $versions = array(); $dirs = glob("$path/*", GLOB_ONLYDIR); foreach ($dirs as $dir) { $dirName = substr($dir, strlen($path) + 1); if (!preg_match('/^(?:ZendFramework-)?(\d+\.\d+\.\d+((a|b|pl|pr|p|rc)\d+)?)(?:-minimal)?$/i', $dirName, $matches)) { continue; } $matchedVersion = $matches[1]; if (('latest' == $version) || ((strlen($matchedVersion) >= $versionLen) && (0 === strpos($matchedVersion, $version))) ) { $versions[$matchedVersion] = $dir . '/library'; } } uksort($versions, 'version_compare'); return $versions; } } 
class Zend_Validate_Exception extends Zend_Exception {} 
class Zend_Registry extends ArrayObject { private static $_registryClassName = 'Zend_Registry'; private static $_registry = null; public static function getInstance() { if (self::$_registry === null) { self::init(); } return self::$_registry; } public static function setInstance(Zend_Registry $registry) { if (self::$_registry !== null) { throw new Zend_Exception('Registry is already initialized'); } self::setClassName(get_class($registry)); self::$_registry = $registry; } protected static function init() { self::setInstance(new self::$_registryClassName()); } public static function setClassName($registryClassName = 'Zend_Registry') { if (self::$_registry !== null) { throw new Zend_Exception('Registry is already initialized'); } if (!is_string($registryClassName)) { throw new Zend_Exception("Argument is not a class name"); } if (!class_exists($registryClassName)) { Zend_Loader::loadClass($registryClassName); } self::$_registryClassName = $registryClassName; } public static function _unsetInstance() { self::$_registry = null; } public static function get($index) { $instance = self::getInstance(); if (!$instance->offsetExists($index)) { throw new Zend_Exception("No entry is registered for key '$index'"); } return $instance->offsetGet($index); } public static function set($index, $value) { $instance = self::getInstance(); $instance->offsetSet($index, $value); } public static function isRegistered($index) { if (self::$_registry === null) { return false; } return self::$_registry->offsetExists($index); } public function __construct($array = array(), $flags = parent::ARRAY_AS_PROPS) { parent::__construct($array, $flags); } public function offsetExists($index) { return array_key_exists($index, $this); } } 
class Zend_Validate_Ip extends Zend_Validate_Abstract { const INVALID = 'ipInvalid'; const NOT_IP_ADDRESS = 'notIpAddress'; protected $_messageTemplates = array( self::INVALID => "Invalid type given, value should be a string", self::NOT_IP_ADDRESS => "'%value%' does not appear to be a valid IP address", ); protected $_options = array( 'allowipv6' => true, 'allowipv4' => true ); public function __construct($options = array()) { if ($options instanceof Zend_Config) { $options = $options->toArray(); } else if (!is_array($options)) { $options = func_get_args(); $temp['allowipv6'] = array_shift($options); if (!empty($options)) { $temp['allowipv4'] = array_shift($options); } $options = $temp; } $options += $this->_options; $this->setOptions($options); } public function getOptions() { return $this->_options; } public function setOptions($options) { if (array_key_exists('allowipv6', $options)) { $this->_options['allowipv6'] = (boolean) $options['allowipv6']; } if (array_key_exists('allowipv4', $options)) { $this->_options['allowipv4'] = (boolean) $options['allowipv4']; } if (!$this->_options['allowipv4'] && !$this->_options['allowipv6']) { throw new Zend_Validate_Exception('Nothing to validate. Check your options'); } return $this; } public function isValid($value) { if (!is_string($value)) { $this->_error(self::INVALID); return false; } $this->_setValue($value); if (($this->_options['allowipv4'] && !$this->_options['allowipv6'] && !$this->_validateIPv4($value)) || (!$this->_options['allowipv4'] && $this->_options['allowipv6'] && !$this->_validateIPv6($value)) || ($this->_options['allowipv4'] && $this->_options['allowipv6'] && !$this->_validateIPv4($value) && !$this->_validateIPv6($value))) { $this->_error(self::NOT_IP_ADDRESS); return false; } return true; } protected function _validateIPv4($value) { $ip2long = ip2long($value); if($ip2long === false) { return false; } return $value == long2ip($ip2long); } protected function _validateIPv6($value) { if (strlen($value) < 3) { return $value == '::'; } if (strpos($value, '.')) { $lastcolon = strrpos($value, ':'); if (!($lastcolon && $this->_validateIPv4(substr($value, $lastcolon + 1)))) { return false; } $value = substr($value, 0, $lastcolon) . ':0:0'; } if (strpos($value, '::') === false) { return preg_match('/\A(?:[a-f0-9]{1,4}:){7}[a-f0-9]{1,4}\z/i', $value); } $colonCount = substr_count($value, ':'); if ($colonCount < 8) { return preg_match('/\A(?::|(?:[a-f0-9]{1,4}:)+):(?:(?:[a-f0-9]{1,4}:)*[a-f0-9]{1,4})?\z/i', $value); } if ($colonCount == 8) { return preg_match('/\A(?:::)?(?:[a-f0-9]{1,4}:){6}[a-f0-9]{1,4}(?:::)?\z/i', $value); } return false; } } 
class Zend_Mail_Protocol_Exception extends Zend_Mail_Exception {} 
